Boolean Gates

    For X, Y

    AND - both 1, result 1
    OR - Any 1, result 1
    NOT - Reverse of Input
    NAND - Not of AND

    DeMorgan Law #### JUST WORKS ####

        NOT(x) OR NOT(y) = NOT ( x AND y)
        NOT(x) AND NOT(y) = NOT ( x OR y)

    -> Every boolean function can be formed only using AND, OR & NOT.. Just write a formula that's true only for 1 row in a truth table & false for every other... then OR such formulas for each row together to get a single formula for the whole table
    -> Every boolean function can be formed using AND & NOT... OR can be written in the form of AND & NOT using DeMorgan formula ... which is 
        NOT(x) OR NOT(y) = NOT(x AND y) .... So,
        x OR y = NOT(NOT(x) AND NOT(y))
        Hence Proved.
    -> Every boolean function can be formed using NAND
        NAND(x,x) = NOT (x AND x) = NOT(x)
        NAND(NAND(x,y), NAND(x,y)) = NOT(NAND(x,y)) = AND (x,y)
        NAND(NAND(x,x), NAND(y,y)) = NAND(NOT(x), NOT(y)) = NOT(NOT(x) AND NOT(y)) = OR(x,y) {DeMorgan Law}
        Hence Proved.

Special Gates

    Mux - 1 Output, Many inputs model. Selector bits selects one input to forward it to the output
    DMux - 1 Input, Many outputs model. Selector bits selects which output input should be forwarded to. All other outputs get an output of 0.

Binary Numbers

    Counting is done only using 2 symbols - 0,1
    Key is ... These symbols can be used to count ANYTHING, ANY concept.
    As a result, when we run out of symbols to count things, we create groups of things and we count those groups ! When we run out of symbols to count groups likewise, we create groups of groups and count that !! The key is these symbols can be used to count any abstract entity !! There is no preference in the choice of entity !!
    And, these countings of different entities is denoted by the place of the digit in a given number.
    So, 347 means 7 counts things. 4 counts 10s of things. 3 counts 10s of 10 things and so on...

    So, a binary number "abcdefg" can be converted to decimal by
        g*2^0 + f*2^1 + e*2^2 .... etc

Binary Addition

    Half-Adder - Sum of two bits... 1 + 1 makes 2 of some things, which is running out of symbols..So, make a group and count it as 1. So, 1 + 1 = 10 !!
    Full-Adder - Sum of three bits... 1 + 1 + 1 = 3, runs out of symbols. Create groups. One group possible, and 1 thing remains. So, 1 + 1 + 1 = 11 !!
    Addition - If a number is represented only by 4 bits. Then the 5th bit carry is THROWN AWAY (OverFlow)


Negative Numbers

    - Initially they used last bit to indicate whether it is a negative or positive number.
    But this created both a (positive zero) +0 and a (negative zero) -0
    - So, they created the 2's complement 

    2's Complement is, -x is represented as 16 - x 

        Binary      Decimal     Decimal in 2's complement

        0000           0                0    
        0001           1                1
        0010           2                2
        0011           3                3
        0100           4                4    
        0101           5                5
        0110           6                6
        0111           7                7
        1000           8                -8 CONFUSION, (8 or -8) ???, like (+0 and -0)
        1001           9                -7
        1010           10               -6
        1011           11               -5
        1100           12               -4
        1101           13               -3
        1110           14               -2
        1111           15               -1
    10000 = 16, the choice for 2's complement  

   The reason for choosing 16,
        1. If we choose a number like 19, then -2 will be calculated as 19 - 2, 17, which ALSO can not be represented by the 4 bits.
        2. 16 is the first number that can not be represented by 4 bits. So, any number u subtract from 16, will definitely find a place among the 4 bits.
        3. This 16 we have added to all negative numbers to represent them as positive numbers is MOST LIKELY to get eliminated during addition's overflow mechanism !! The times it doesn't get eliminated, the answers themselves turn out to be a negative number !!! And the arithmetics #### JUST WORKS ####
    
    Elimination of 16, during addition (to remove the unwanted 16 we introduced to negative numbers) happens automatically due to addition's overflow flaw. The times that this does not happen are times the results themselves are a negative number, So, the 16 we added is conveniently left around untouched. The math #### JUST WORKS #### automatically in all cases.

    Case 1 - Addition of -ve numbers
        Case 1.1
            7 - 4 = 7 + (16 - 4) = 7 + 12 = 19 (flaw) = 3 
            So, the 16 we added forcefully to negative numbers, we lost it automatically through addition's flaw.
        Case 1.2 
            3 - 7 = 3 + (16 - 7) = 3 + 9 = 12 (-4)
            Here, the 16 we added forcefully, never gets removed and that's exactly what we WANT.
            The answer is a negative number
        Case 1.3
            -3 - 4 = (16 - 3) + (16 - 4) = 13 + 12 = 25 (flaw) = 9 (-7)
            Here, we added two 16s forcefully, only one got removed, one stayed and that's because result is a negative number !

    OVERFLOW Problems during arithmetics of boolean numbers - 

        1. 5 + 5 = 10 (-6) .. Addition of positive numbers overflows into negative numbers.
        3. -5 -5 = (16 - 5) + (16 - 5) = 11 + 11 = 22 (flaw) = 6 ... Addition of negative numbers overflows into positive numbers.

        But everywhere else, it #### JUST WORKS ####

    How we do the 2's complement?
        x is taken as 16 - x 
        16 - x = (15 - x) + 1 = !x + 1

    How is (15 - x) equals to !x?
        When u subtract any number, x from 1111, the result is the 4-bit NOT of that number
          1111
        - 0101
        = 1010

ALU

    This system has a list of functions that it carries out on the inputs a, b
    But the function to be performed needs to be selected using selector bits
    Basically, ALU is a MUX of functions

    And in order to understand how ALU functions work, You need to remember ONLY one basic rule of boolean arithmetic,
    which is, (15 - x) equals !X

    Selector bits
    
    zx -> x = 0000 if 1
    nx -> x = !x if 1
    zy -> y = 0000 if 1
    ny -> y = !y if 1
    f -> x+y (arithmetic addition) if 1, x&y (bit-wise AND) if 0 
    no -> !f if 1, f if 0

    Output bits

    zr -> if out is 0, then 1
    ng -> if out is negative, then 1

    Selector bit Functionality derived !!!
    
    zx  nx  zy  ny  f   no  out     Explained     
    1   0   1   0   1   0   0     x=0000, y=0000, f=0000 (+), no=0000, out=0 
    1   1   1   1   1   1   1     x=1111, y=1111, f=1110 (+), no=0001, out=1 
    1   1   1   0   1   0   -1    x=1111, y=0000, f=1111 (+), no=1111, out=-1 (1111 is -1 in 2's complement)
    0   0   1   1   0   0   x     x=x, y=1111, f=x (&), no=x, out=x
    1   1   0   0   0   0   y     x=1111, y=y, f=y (&), no=y, out=y
    0   0   1   1   0   1   !x    x=x, y=1111, f=x (&), no=!x, out=!x
    1   1   0   0   0   1   !y    x=1111, y=y, f=y (&), no=!y, out=!y
    0   0   1   1   1   1   -x    x=x, y=1111, f=15+x (+), no=!(15+x), out = !(16+x-1) = !(x-1) = 15-x+1 = 16-x = -x 
    1   1   0   0   1   1   -y    x=1111, y=y, f=15+y (+), no=!(15+y), out = !(16+y-1) = !(y-1) = 15-y+1 = 16-y = -y
    0   1   1   1   1   1   x+1   x=!x, y=1111, f=15+!x (+), no=!(15+!x), out = !(15+15-x) = 15-15-15+x = -16+x+1 = x+1 
    1   1   0   1   1   1   y+1   x=1111, y=!y, f=15+!y (+), no=!(15+!y), out = !(15+15-y) = 15-15-15+y = -16+y+1 = y+1
    0   0   1   1   1   0   x-1   x=x, y=1111, f=15+x (+), no=15+x, out = (16+x-1) = x-1 
    1   1   0   0   1   0   y-1   x=1111, y=y, f=15+y (+), no=15+y, out = (16+y-1) = y-1
    0   0   0   0   1   0   x+y   x=x, y=y, f=x+y (+), no=x+y, out=x+y
    0   1   0   0   1   1   x-y   x=!x, y=y, f=y+!x (+), no=!(y+!x), out = !(y+15-x) = 15-y-15+x = x-y
    0   0   0   1   1   1   y-x   x=x, y=!y, f=x+!y (+), no=!(x+!y), out = !(x+15-y) = 15-x-15+y = y-x
    0   0   0   0   0   0   x&y   x=x, y=y, f=x&y (&), no=x&y, out=x&y
    0   1   0   1   0   1   x|y   x=!x, y=!y, f=!x AND !y (&), no=NOT(!x AND !y), out= x OR y (DeMorgan Law)

    2 Important Principles to derive all functionalities of ALU

        1. 16 is 10000, 5 bits. So, it can NOT be represented in the 4 bits world. So, practically 16 is the new 0. 
            16 will always get removed or ignored.
        2. 15 - x = 1111 - x = !x. Basically, if you do the math and see, since 15 has all 1s possible (for 4 bits).
            There wont be ANY borrow necessary ever. So, if x has any 1s, it will become 0. And if x has zeros, 15's 1s will descend replacing those zeroes. So, subtracting x from 15, is a neat way to do NOT !!

Sequential chips

    So, far we have dealt with combinatorial chips.
    From a hardware persepective, combinatorial chips are chips that process outputs in a negligible amount of time.
    While sequential chips are chips that take time to stabilize themselves before returning a output.

    This is the reason why .. we introduce CLOCK CYCLES.

    Clock cycle is the minimum amount of time to wait before expecting a sequential chip to output.
    As, a result, sequential chips process input with a time delay of 1 clock cycle.

    Therefore, the only difference is, combinatorial chips process input in the same clock cycle while sequential chips process & output only in the next clock cycle.
    
    Sequential Chips - input at time T, output at time T+1
    Combinatorial Chips - input at time T, output at time T

    D-FlipFlop

        Is a chip that takes input at time T and outputs the input at time T+1
    
Memory

    1-Bit Chip 
    
        - Is the smallest unit of memory
        - You can read & write values to it
        - A load bit is used to signal a Mux inside it, whether we are writing or reading from it. 
        - If it's write, the Mux, takes the incoming input and forwards it to the D-FlipFlop inside.
        - If it's read, the Mux, takes the ouput of the D-FlipFlop and pipes it back to the D-FlipFlop itself.
        
        This looping mechanism, of wiring the ouput of the D-FlipFlop as its own input helps the 1-bit chip to store values eternally.
        
    Register (16-bit, 32-bit, 64-bit Multi-Chip)
        
        It's a bus of 1-bit chips.
    
    RAM (RAM8, RAM64, RAM512, RAM4K, RAM16K)

        - Is a MUX over a Bus of many Registers or other RAMs.
        - Only one register can be accessed at any time. RAM is a MUX of Registers & other RAMs, so only 1 output.
        - Access time to any register is the SAME, Irrespective of RAM's size and register's location.
        - Volatile - loses memory if it loses power.
        - Width is Register Width - How many 1-bit chips each register is made of, Our case 16-bits
        - Address is RAM's selector bits. It depends on how many registers or RAMs, the RAM has packed in it.

    Program Counter

        A special register of 16, 1-Bit chips, to store the address of the program we are executing.
        It's a counter that can be reset to 0, loaded a new value, incremented by 1, or remain the same.
        Since, there is a if-else in its definition, u need to write the truth table down, find the logic Gates
        that wud help u construct the selector bits for Mux, which can then be easily used to select 1 output among 4
        different outputs
    
        
PROJECT3 - COPY 
        I didnt know how to read out[t] & set out[t+1] from these sequential chips in HDL.
        I didnt kno the right syntax to use for that. Turns out DFF's out needs to be mentioned twice. 
        The auto-complete plugin i was using never mentioned that.
        Cheat-Sheet & AppendixA couldn't help.
        Checked online.
        And while programming PC, found out in the CHEAT-SHEET, under the section of "Multiple outputs" (A non-obvious name to index by), the last paragraph mentions in one single line, sequential chips's previous timestamp outputs can be retrieved using the same out keyword.





-------------------------------------------------------------------------------







    
    




        


    


