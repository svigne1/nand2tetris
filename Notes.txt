Boolean Gates

    For X, Y

    AND - both 1, result 1
    OR - Any 1, result 1
    NOT - Reverse of Input
    NAND - Not of AND

    DeMorgan Law #### JUST WORKS ####

        NOT(x) OR NOT(y) = NOT ( x AND y)
        NOT(x) AND NOT(y) = NOT ( x OR y)

    -> Every boolean function can be formed only using AND, OR & NOT.. Just write a formula that's true only for 1 row in a truth table & false for every other... then OR such formulas for each row together to get a single formula for the whole table
    -> Every boolean function can be formed using AND & NOT... OR can be written in the form of AND & NOT using DeMorgan formula ... which is 
        NOT(x) OR NOT(y) = NOT(x AND y) .... So,
        x OR y = NOT(NOT(x) AND NOT(y))
        Hence Proved.
    -> Every boolean function can be formed using NAND
        NAND(x,x) = NOT (x AND x) = NOT(x)
        NAND(NAND(x,y), NAND(x,y)) = NOT(NAND(x,y)) = AND (x,y)
        NAND(NAND(x,x), NAND(y,y)) = NAND(NOT(x), NOT(y)) = NOT(NOT(x) AND NOT(y)) = OR(x,y) {DeMorgan Law}
        Hence Proved.

Special Gates

    Mux - 1 Output, Many inputs model. Selector bits selects one input to forward it to the output
    DMux - 1 Input, Many outputs model. Selector bits selects which output input should be forwarded to. All other outputs get an output of 0.

Binary Numbers

    Counting is done only using 2 symbols - 0,1
    Key is ... These symbols can be used to count ANYTHING, ANY concept.
    As a result, when we run out of symbols to count things, we create groups of things and we count those groups ! When we run out of symbols to count groups likewise, we create groups of groups and count that !! The key is these symbols can be used to count any abstract entity !! There is no preference in the choice of entity !!
    And, these countings of different entities is denoted by the place of the digit in a given number.
    So, 347 means 7 counts things. 4 counts 10s of things. 3 counts 10s of 10 things and so on...

    So, a binary number "abcdefg" can be converted to decimal by
        g*2^0 + f*2^1 + e*2^2 .... etc

Binary Addition

    Half-Adder - Sum of two bits... 1 + 1 makes 2 of some things, which is running out of symbols..So, make a group and count it as 1. So, 1 + 1 = 10 !!
    Full-Adder - Sum of three bits... 1 + 1 + 1 = 3, runs out of symbols. Create groups. One group possible, and 1 thing remains. So, 1 + 1 + 1 = 11 !!
    Addition - If a number is represented only by 4 bits. Then the 5th bit carry is THROWN AWAY (OverFlow)


Negative Numbers

    - Initially they used last bit to indicate whether it is a negative or positive number.
    But this created both a (positive zero) +0 and a (negative zero) -0
    - So, they created the 2's complement 

    2's Complement #### JUST WORKS ####

        Binary      Decimal     Decimal in 2's complement

        0000           0                0    
        0001           1                1
        0010           2                2
        0011           3                3
        0100           4                4    
        0101           5                5
        0110           6                6
        0111           7                7
        1000           8                -8 CONFUSION, (8 or -8) ???, like (+0 and -0)
        1001           9                -7
        1010           10               -6
        1011           11               -5
        1100           12               -4
        1101           13               -3
        1110           14               -2
        1111           15               -1
    10000 = 16, the choice for 2's complement  

   The reason for choosing 16,
        1. If we choose a number like 19, then -2 will be calculated as 19 - 2, 17, which ALSO can not be represented by the 4 bits.
        2. 16 is the first number that can not be represented by 4 bits. So, any number u subtract from 16, will definitely find a place among the 4 bits.
        3. This 16 we have added to all negative numbers to represent them as positive numbers is MOST LIKELY to get eliminated during addition's overflow mechanism !! The times it doesn't get eliminated, the answers themselves turn out to be a negative number !!!
    
    Auto-Elimination of 16, during arithmetics of negative numbers to remove the unwanted 16 we introduced... works only when... the result is a positive number. It conveniently leaves the 16 lying aroung if the result is also a negative number !!
    Epdi da ithellaan?? Looks like magic !!!
    The addition if results in a -ve number, it stays within the 4 bits automatically.
    If the result is a positive number, automatically, it goes over the ledge, losing a 16, and exactly landing at the right number!
    MAGIC - It #### JUST WORKS ####

        1. 7 - 1 = 7 + (16 - 1) = 7 + 15 = 22 (addition overflow) = 6 
        2. 1 - 7 = 1 + (16 - 7) = 1 + 9 = 10 (-6)
        3. -3 - 4 = (16 - 3) + (16 - 4) = 13 + 12 = 25 (addition overflow) = 9 (-7)

    Problems during arithmetics of negative numbers

        1. 5 + 5 = 10 (-6) .. Addition of positive numbers overflow into negative numbers.
        3. -5 -5 = (16 - 5) + (16 - 5) = 11 + 11 = 22 (addition overflow) = 6 ... Addition of negative numbers overflows into positive numbers.

        But everywhere else, it #### JUST WORKS ####


    
    




        


    


